# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

af <- function(obj, lookup_scale, lookup_byte) {
    .Call('_pcadapt_af', PACKAGE = 'pcadapt', obj, lookup_scale, lookup_byte)
}

bedXPtr <- function(path, n, p) {
    .Call('_pcadapt_bedXPtr', PACKAGE = 'pcadapt', path, n, p)
}

bedadaptXPtr <- function(path, n, p) {
    .Call('_pcadapt_bedadaptXPtr', PACKAGE = 'pcadapt', path, n, p)
}

cmpt_af <- function(xp_) {
    .Call('_pcadapt_cmpt_af', PACKAGE = 'pcadapt', xp_)
}

prodMatVec <- function(xp_, x, m, s, pass) {
    .Call('_pcadapt_prodMatVec', PACKAGE = 'pcadapt', xp_, x, m, s, pass)
}

prodtMatVec <- function(xp_, x, m, s, pass) {
    .Call('_pcadapt_prodtMatVec', PACKAGE = 'pcadapt', xp_, x, m, s, pass)
}

linReg <- function(xp_, u, d, v, m) {
    .Call('_pcadapt_linReg', PACKAGE = 'pcadapt', xp_, u, d, v, m)
}

#' Covariance for loaded genotype data
#' 
#' \code{cmpt_cov_cpp} computes the covariance matrix of a genotype matrix.
#' 
#' @param filename a character string specifying the name of the file to be 
#' processed with \code{pcadapt}.
#' @param xmatrix a genotype matrix.
#' @param min_maf a value between \code{0} and \code{0.45} specifying the 
#' threshold of minor allele frequencies above which p-values are computed.
#' @param ploidy an integer specifying the ploidy of the individuals.
#' @param type an integer specifying the input type: \code{0} for genotype 
#' matrices or \code{1} for genotype files.
#' @param blocksize an integer specifying the number of rows for each block.
#' 
#' @return The returned value is a Rcpp::List containing the covariance matrix, 
#' the number of individuals and the number of genetic markers present in the 
#' data.
#' 
#' @export
#' 
cmpt_cov_cpp <- function(filename, xmatrix, min_maf, ploidy, type, blocksize = 120L) {
    .Call('_pcadapt_cmpt_cov_cpp', PACKAGE = 'pcadapt', filename, xmatrix, min_maf, ploidy, type, blocksize)
}

#' Cartesian coordinates to barycentric coordinates
#' 
#' \code{cart2bary_cpp} returns the barycentric coordinates.
#' 
#' @param X a matrix.
#' @param P a matrix.
#' 
#' @return The returned value is a numeric matrix.
#' 
#' @export
#' 
cart2bary_cpp <- function(X, P) {
    .Call('_pcadapt_cart2bary_cpp', PACKAGE = 'pcadapt', X, P)
}

#' Genotype matrix imputation
#' 
#' \code{impute_geno} imputes values based on the median per row.
#' 
#' @param x a genotype matrix.
#' 
#' @return The returned value is a list containing the imputed genotype matrix and a vector indicating which markers 
#' have to be discarded.
#' 
#' @export
#' 
impute_geno <- function(x) {
    .Call('_pcadapt_impute_geno', PACKAGE = 'pcadapt', x)
}

#' Genotype matrix imputation
#' 
#' \code{impute_geno_pop} imputes values based on the median per row and per population.
#' 
#' @param x a genotype matrix.
#' @param lab a vector of integers.
#' @param pop a vector of integers.
#' 
#' @return The returned value is a list containing the imputed genotype matrix and a vector indicating which markers 
#' have to be discarded.
#' 
#' @export
#' 
impute_geno_pop <- function(x, lab, pop) {
    .Call('_pcadapt_impute_geno_pop', PACKAGE = 'pcadapt', x, lab, pop)
}

#' \code{get_window}
#' 
#' @param i an integer.
#' @param map a vector containing the genetic positions in Morgans.
#' @param window_size a numeric value specifying the window size en Morgans.
#' 
#' @return The returned value is a numeric vector.
#' 
#' @export
#' 
get_window <- function(i, map, window_size) {
    .Call('_pcadapt_get_window', PACKAGE = 'pcadapt', i, map, window_size)
}

#' Global Principal Component Analysis
#' 
#' \code{cmpt_global_pca} computes the scores using all genetic markers.
#' 
#' @param geno a genotype matrix.
#' @param V a loading matrix.
#' @param sigma a vector of singular values.
#' 
#' @return The returned value is a matrix of scores.
#' 
#' @export
#' 
cmpt_global_pca <- function(geno, V, sigma) {
    .Call('_pcadapt_cmpt_global_pca', PACKAGE = 'pcadapt', geno, V, sigma)
}

#' Local Principal Component Analysis
#' 
#' \code{cmpt_local_pca} computes the scores using a subset of genetic markers.
#' 
#' @param geno a genotype matrix.
#' @param V a loading matrix.
#' @param sigma a vector of singular values.
#' @param beg an integer specifying the first marker to be included.
#' @param end an integer specifying the first marker to be excluded.
#' 
#' @return The returned value is a matrix of scores.
#' 
#' @export
#' 
cmpt_local_pca <- function(geno, V, sigma, beg, end) {
    .Call('_pcadapt_cmpt_local_pca', PACKAGE = 'pcadapt', geno, V, sigma, beg, end)
}

#' Update local Principal Component Analysis
#' 
#' \code{updt_local_scores} computes the scores using a subset of genetic 
#' markers.
#' 
#' @param u a score matrix.
#' @param geno a genotype matrix.
#' @param V a loading matrix.
#' @param sigma a vector of singular values.
#' @param beg_old an integer specifying the first marker to be included.
#' @param end_old an integer specifying the first marker to be excluded.
#' @param beg_new an integer specifying the first marker to be included.
#' @param end_new an integer specifying the first marker to be excluded.
#' 
#' @return The returned value is a score matrix.
#' 
#' @export
#' 
updt_local_scores <- function(u, geno, V, sigma, beg_old, end_old, beg_new, end_new) {
    invisible(.Call('_pcadapt_updt_local_scores', PACKAGE = 'pcadapt', u, geno, V, sigma, beg_old, end_old, beg_new, end_new))
}

cmpt_af_matrix <- function(G) {
    .Call('_pcadapt_cmpt_af_matrix', PACKAGE = 'pcadapt', G)
}

prodGx_matrix <- function(G, x, m, s, pass) {
    .Call('_pcadapt_prodGx_matrix', PACKAGE = 'pcadapt', G, x, m, s, pass)
}

prodtGx_matrix <- function(G, x, m, s, pass) {
    .Call('_pcadapt_prodtGx_matrix', PACKAGE = 'pcadapt', G, x, m, s, pass)
}

#' Robust estimates for location and scatter
#'
#' \code{covRob_cpp} implements the Orthogonalized Gnanadesikan-Kettenring estimator
#' of Maronna and Zamar.
#'
#' @param x a numeric matrix.
#' 
#' @examples
#' ## see also ?pcadapt for examples
#'
#' @export
#'
covRob_cpp <- function(x) {
    .Call('_pcadapt_covRob_cpp', PACKAGE = 'pcadapt', x)
}

#' Summary
#'
#' \code{print_convert} prints out a summary of the file conversion.
#'
#' @param input a genotype matrix or a character string specifying the name of the file to be converted.
#' @param output a character string specifying the name of the output file.
#' @param M an integer specifying the number of genetic markers present in the data.
#' @param N an integer specifying the number of individuals present in the data.
#' @param pool an integer specifying the type of data. `0` for genotype data, `1` for pooled data.
#'
#' @examples
#' ## see also ?pcadapt for examples
#'
#' @export
#'
print_convert <- function(input, output, M, N, pool) {
    invisible(.Call('_pcadapt_print_convert', PACKAGE = 'pcadapt', input, output, M, N, pool))
}

#' Convert ped files
#'
#' \code{ped2pcadapt} converts \code{ped} files to the format \code{pcadapt}.
#'
#' @param input a character string specifying the name of the file to be converted.
#' @param output a character string specifying the name of the output file.
#' 
#' @examples
#' ## see also ?pcadapt for examples
#'
#' @keywords internal
#'
#' @export
#'
ped2pcadapt <- function(input, output) {
    .Call('_pcadapt_ped2pcadapt', PACKAGE = 'pcadapt', input, output)
}

#' Convert lfmm files
#'
#' \code{lfmm2pcadapt} converts \code{lfmm} files to the format \code{pcadapt}.
#'
#' @param input a character string specifying the name of the file to be converted.
#' @param output a character string specifying the name of the output file.
#' 
#' @examples
#' ## see also ?pcadapt for examples
#'
#' @keywords internal
#'
#' @export
#'
lfmm2pcadapt <- function(input, output) {
    .Call('_pcadapt_lfmm2pcadapt', PACKAGE = 'pcadapt', input, output)
}

#' Sample genotype matrix from pooled samples
#' 
#' \code{sample_geno_matrix} sample genotypes based on observed allelic frequencies.
#' 
#' @param freq a matrix containing allele frequencies.
#' @param ploidy an integer specifying the ploidy of the sampled individuals.
#' @param sample_size a vector specifying the number of individuals to be sampled for each pool.
#' 
#' @return The returned value is a numeric vector of length 2.
#' 
#' @export
#' 
sample_geno_matrix <- function(freq, ploidy, sample_size) {
    .Call('_pcadapt_sample_geno_matrix', PACKAGE = 'pcadapt', freq, ploidy, sample_size)
}

#' Get population size
#' 
#' \code{get_pop_size} 
#' 
#' @param pop a string vector.
#' @param popUnique a string vector.
#' 
#' @return The returned value is a numeric matrix.
#' 
#' @export
#' 
get_pop_size <- function(pop, popUnique) {
    .Call('_pcadapt_get_pop_size', PACKAGE = 'pcadapt', pop, popUnique)
}

#' Introgression statistics
#' 
#' \code{slidingWindows_fast} 
#' 
#' @param sgeno a scaled genotype matrix.
#' @param d a numeric vector.
#' @param v a numeric matrix.
#' @param pop a string vector.
#' @param popUnique a string vector.
#' @param admixed a character vector.
#' @param window_size a numeric value.
#' @param map a numeric vector.
#' @param with_map an integer.
#' 
#' @return The returned value is a numeric matrix.
#' 
#' @export
#' 
slidingWindows_fast <- function(sgeno, d, v, pop, popUnique, admixed, window_size, map, with_map) {
    .Call('_pcadapt_slidingWindows_fast', PACKAGE = 'pcadapt', sgeno, d, v, pop, popUnique, admixed, window_size, map, with_map)
}

#' Introgression statistics
#' 
#' \code{slidingWindows_new} 
#' 
#' @param sgeno a scaled genotype matrix.
#' @param d a numeric vector.
#' @param v a numeric matrix.
#' @param pop a string vector.
#' @param popUnique a string vector.
#' @param admixed a character vector.
#' @param window_size a numeric value.
#' @param map a numeric vector.
#' @param with_map an integer.
#' 
#' @return The returned value is a numeric matrix.
#' 
#' @export
#' 
slidingWindows_new <- function(sgeno, d, v, pop, popUnique, admixed, window_size, map, with_map) {
    .Call('_pcadapt_slidingWindows_new', PACKAGE = 'pcadapt', sgeno, d, v, pop, popUnique, admixed, window_size, map, with_map)
}

get_fitted_matrix <- function(Y, U) {
    .Call('_pcadapt_get_fitted_matrix', PACKAGE = 'pcadapt', Y, U)
}

clumping_cpp <- function(G, ord, remain, sumX, denoX, size, thr) {
    .Call('_pcadapt_clumping_cpp', PACKAGE = 'pcadapt', G, ord, remain, sumX, denoX, size, thr)
}

#' \code{pca_rotation}
#' 
#' @param a a numeric matrix.
#' @param b a numeric matrix.
#' 
#' @return The returned value is a numeric vector.
#' 
#' @export
#'
pca_rotation <- function(a, b) {
    .Call('_pcadapt_pca_rotation', PACKAGE = 'pcadapt', a, b)
}

#' File size
#' 
#' \code{get_size_cpp} returns the number of genetic markers and the number of 
#' individuals present in the data.
#' 
#' @param filename a character string specifying the name of the file to be 
#' processed with \code{pcadapt}.
#' 
#' @return The returned value is a numeric vector of length 2.
#' 
#' @export
#' 
get_size_cpp <- function(filename) {
    .Call('_pcadapt_get_size_cpp', PACKAGE = 'pcadapt', filename)
}

#' Number of individuals in a specific population
#' 
#' \code{get_nb_ind} returns the number of individuals in a specific population.
#' 
#' @param pop a string vector.
#' @param name a character vector.
#' 
#' @return The returned value is an integer.
#' 
#' @export
#' 
get_nb_ind <- function(pop, name) {
    .Call('_pcadapt_get_nb_ind', PACKAGE = 'pcadapt', pop, name)
}

#' Minor allele frequencies
#' 
#' \code{cmpt_minor_af} computes the minor allele frequencies.
#' 
#' @param xmatrix a genotype matrix.
#' @param ploidy an integer specifying the ploidy of the individuals.
#' 
#' @return The returned value is a numeric matrix.
#' 
#' @export
#' 
cmpt_minor_af <- function(xmatrix, ploidy) {
    .Call('_pcadapt_cmpt_minor_af', PACKAGE = 'pcadapt', xmatrix, ploidy)
}

#' Scale genotype matrices
#' 
#' \code{scale_geno} scales the genotype matrix.
#' 
#' @param xmatrix a genotype matrix.
#' @param ploidy an integer specifying the ploidy of the individuals.
#' @param maf a vector of minor allele frequencies.
#' @param keep_or_not a vector of integers.
#' 
#' @return The returned value is a numeric matrix.
#' 
#' @export
#' 
scale_geno <- function(xmatrix, ploidy, maf, keep_or_not) {
    .Call('_pcadapt_scale_geno', PACKAGE = 'pcadapt', xmatrix, ploidy, maf, keep_or_not)
}

#' Compute the loadings
#' 
#' \code{cmpt_loadings} returns the loadings.
#' 
#' @param filename a character string specifying the name of the file to be 
#' processed with \code{pcadapt}.
#' @param xmatrix a genotype matrix.
#' @param scores a matrix containing the scores.
#' @param nIND an integer specifying the number of individuals present in the 
#' data.
#' @param nSNP an integer specifying the number of genetic markers present in 
#' the data.
#' @param K an integer specifying the number of principal components to retain.
#' @param ploidy an integer specifying the ploidy of the individuals.
#' @param min_maf a value between \code{0} and \code{0.45} specifying the 
#' threshold of minor allele frequencies above which p-values are computed.
#' @param sigma a numeric vector.
#' @param type an integer specifying the input type.
#' 
#' @return The returned value is a matrix containing the loadings.
#' 
#' @export
#' 
cmpt_loadings <- function(filename, xmatrix, scores, nIND, nSNP, K, ploidy, min_maf, sigma, type) {
    .Call('_pcadapt_cmpt_loadings', PACKAGE = 'pcadapt', filename, xmatrix, scores, nIND, nSNP, K, ploidy, min_maf, sigma, type)
}

#' Linear regression
#' 
#' \code{lrfunc_cpp} performs the multiple linear regression of the genotype 
#' matrix on the scores.
#' 
#' @param filename a character string specifying the name of the file to be 
#' processed with \code{pcadapt}.
#' @param xmatrix a genotype matrix.
#' @param scores a matrix containing the scores.
#' @param nIND an integer specifying the number of individuals present in the 
#' data.
#' @param nSNP an integer specifying the number of genetic markers present in 
#' the data.
#' @param K an integer specifying the number of principal components to retain.
#' @param ploidy an integer specifying the ploidy of the individuals.
#' @param min_maf a value between \code{0} and \code{0.45} specifying the 
#' threshold of minor allele frequencies above which p-values are computed.
#' @param sigma a numeric vector.
#' @param type an integer specifying the input type.
#' 
#' @return The returned value is a Rcpp::List containing the multiple linear 
#' regression z-scores, the minor allele frequencies and the number of missing 
#' values for each genetic marker.
#' 
#' @export
#' 
lrfunc_cpp <- function(filename, xmatrix, scores, nIND, nSNP, K, ploidy, min_maf, sigma, type) {
    .Call('_pcadapt_lrfunc_cpp', PACKAGE = 'pcadapt', filename, xmatrix, scores, nIND, nSNP, K, ploidy, min_maf, sigma, type)
}

#' Sample genotype matrix from pooled samples
#' 
#' \code{sample_geno_file} sample genotypes based on observed allelic frequencies.
#' 
#' @param input a character string specifying the name of the file containing the allele frequencies.
#' @param output a character string specifying the name of the output file.
#' @param ploidy an integer specifying the ploidy of the sampled individuals.
#' @param sample_size a vector specifying the number of individuals to be sampled for each pool.
#' 
#' @return The returned value is a numeric vector of length 2.
#' 
#' @export
#' 
sample_geno_file <- function(input, output, ploidy, sample_size) {
    .Call('_pcadapt_sample_geno_file', PACKAGE = 'pcadapt', input, output, ploidy, sample_size)
}

#' Convert vcfR genotype matrices
#'
#' \code{vcf_convert} converts outputs of \code{extract.gt} to the format 
#' \code{pcadapt}.
#'
#' @param string_geno a genotype matrix extracted from a VCF file with `vcfR`. 
#' @param output a character string indicating the name of the output file.
#' @param allele.sep a vector of characters indicating what delimiters are used 
#' to separate alleles.
#'
#' @examples
#' ## see also ?pcadapt for examples
#'
#' @keywords internal
#'
#' @export
#'
vcf_convert <- function(string_geno, output, allele_sep) {
    .Call('_pcadapt_vcf_convert', PACKAGE = 'pcadapt', string_geno, output, allele_sep)
}

